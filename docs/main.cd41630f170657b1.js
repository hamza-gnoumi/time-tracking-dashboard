"use strict"; (self.webpackChunktime_tracking_dashboard = self.webpackChunktime_tracking_dashboard || []).push([[179], { 2: () => { function X(e) { return "function" == typeof e } function Yr(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const Zr = Yr(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Xn(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class it { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (X(r)) try { r() } catch (i) { t = i instanceof Zr ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Zu(i) } catch (s) { t = t ?? [], s instanceof Zr ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new Zr(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Zu(t); else { if (t instanceof it) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Xn(n, t) } remove(t) { const { _finalizers: n } = this; n && Xn(n, t), t instanceof it && t._removeParent(this) } } it.EMPTY = (() => { const e = new it; return e.closed = !0, e })(); const Ku = it.EMPTY; function Yu(e) { return e instanceof it || e && "closed" in e && X(e.remove) && X(e.add) && X(e.unsubscribe) } function Zu(e) { X(e) ? e() : e.unsubscribe() } const Ut = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, Xr = { setTimeout(e, t, ...n) { const { delegate: r } = Xr; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = Xr; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Xu(e) { Xr.setTimeout(() => { const { onUnhandledError: t } = Ut; if (!t) throw e; t(e) }) } function Qu() { } const fm = Ni("C", void 0, void 0); function Ni(e, t, n) { return { kind: e, value: t, error: n } } let zt = null; function Qr(e) { if (Ut.useDeprecatedSynchronousErrorHandling) { const t = !zt; if (t && (zt = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = zt; if (zt = null, n) throw r } } else e() } class Pi extends it { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Yu(t) && t.add(this)) : this.destination = vm } static create(t, n, r) { return new Qn(t, n, r) } next(t) { this.isStopped ? Fi(function pm(e) { return Ni("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? Fi(function hm(e) { return Ni("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Fi(fm, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const mm = Function.prototype.bind; function xi(e, t) { return mm.call(e, t) } class ym { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { Jr(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { Jr(r) } else Jr(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { Jr(n) } } } class Qn extends Pi { constructor(t, n, r) { let o; if (super(), X(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && Ut.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && xi(t.next, i), error: t.error && xi(t.error, i), complete: t.complete && xi(t.complete, i) }) : o = t } this.destination = new ym(o) } } function Jr(e) { Ut.useDeprecatedSynchronousErrorHandling ? function gm(e) { Ut.useDeprecatedSynchronousErrorHandling && zt && (zt.errorThrown = !0, zt.error = e) }(e) : Xu(e) } function Fi(e, t) { const { onStoppedNotification: n } = Ut; n && Xr.setTimeout(() => n(e, t)) } const vm = { closed: !0, next: Qu, error: function Dm(e) { throw e }, complete: Qu }, Ri = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Ju(e) { return e } let Ee = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function _m(e) { return e && e instanceof Pi || function wm(e) { return e && X(e.next) && X(e.error) && X(e.complete) }(e) && Yu(e) }(n) ? n : new Qn(n, r, o); return Qr(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = tl(r))((o, i) => { const s = new Qn({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Ri]() { return this } pipe(...n) { return function el(e) { return 0 === e.length ? Ju : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } }(n)(this) } toPromise(n) { return new (n = tl(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function tl(e) { var t; return null !== (t = e ?? Ut.Promise) && void 0 !== t ? t : Promise } const Em = Yr(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Oi = (() => { class e extends Ee { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new nl(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new Em } next(n) { Qr(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { Qr(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Qr(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Ku : (this.currentObservers = null, i.push(n), new it(() => { this.currentObservers = null, Xn(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new Ee; return n.source = this, n } } return e.create = (t, n) => new nl(t, n), e })(); class nl extends Oi { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : Ku } } function an(e) { return t => { if (function Cm(e) { return X(e?.lift) }(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Jn(e, t, n, r, o) { return new bm(e, t, n, r, o) } class bm extends Pi { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function er(e, t) { return an((n, r) => { let o = 0; n.subscribe(Jn(r, i => { r.next(e.call(t, i, o++)) })) }) } function Ft(e) { return this instanceof Ft ? (this.v = e, this) : new Ft(e) } function sl(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function Hi(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (l) { i({ value: l, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const al = e => e && "number" == typeof e.length && "function" != typeof e; function ul(e) { return X(e?.then) } function ll(e) { return X(e[Ri]) } function cl(e) { return Symbol.asyncIterator && X(e?.[Symbol.asyncIterator]) } function dl(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const fl = function Wm() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function hl(e) { return X(e?.[fl]) } function pl(e) { return function il(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof Ft ? Promise.resolve(f.value.v).then(l, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function l(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } }(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Ft(n.read()); if (o) return yield Ft(void 0); yield yield Ft(r) } } finally { n.releaseLock() } }) } function gl(e) { return X(e?.getReader) } function Rt(e) { if (e instanceof Ee) return e; if (null != e) { if (ll(e)) return function qm(e) { return new Ee(t => { const n = e[Ri](); if (X(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (al(e)) return function Km(e) { return new Ee(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (ul(e)) return function Ym(e) { return new Ee(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Xu) }) }(e); if (cl(e)) return ml(e); if (hl(e)) return function Zm(e) { return new Ee(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (gl(e)) return function Xm(e) { return ml(pl(e)) }(e) } throw dl(e) } function ml(e) { return new Ee(t => { (function Qm(e, t) { var n, r, o, i; return function rl(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(c) { try { l(r.next(c)) } catch (d) { s(d) } } function u(c) { try { l(r.throw(c)) } catch (d) { s(d) } } function l(c) { c.done ? i(c.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(c.value).then(a, u) } l((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = sl(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function Ot(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function eo(e, t, n = 1 / 0) { return X(t) ? eo((r, o) => er((i, s) => t(r, i, o, s))(Rt(e(r, o))), n) : ("number" == typeof t && (n = t), an((r, o) => function Jm(e, t, n, r, o, i, s, a) { const u = []; let l = 0, c = 0, d = !1; const f = () => { d && !u.length && !l && t.complete() }, h = g => l < r ? p(g) : u.push(g), p = g => { i && t.next(g), l++; let v = !1; Rt(n(g, c++)).subscribe(Jn(t, D => { o?.(D), i ? h(D) : t.next(D) }, () => { v = !0 }, void 0, () => { if (v) try { for (l--; u.length && l < r;) { const D = u.shift(); s ? Ot(t, s, () => p(D)) : p(D) } f() } catch (D) { t.error(D) } })) }; return e.subscribe(Jn(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } const yl = new Ee(e => e.complete()); function Bi(e) { return e[e.length - 1] } function Dl(e) { return function ny(e) { return e && X(e.schedule) }(Bi(e)) ? e.pop() : void 0 } function vl(e, t = 0) { return an((n, r) => { n.subscribe(Jn(r, o => Ot(r, e, () => r.next(o), t), () => Ot(r, e, () => r.complete(), t), o => Ot(r, e, () => r.error(o), t))) }) } function wl(e, t = 0) { return an((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function _l(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new Ee(n => { Ot(n, t, () => { const r = e[Symbol.asyncIterator](); Ot(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function El(e, t) { return t ? function ly(e, t) { if (null != e) { if (ll(e)) return function oy(e, t) { return Rt(e).pipe(wl(t), vl(t)) }(e, t); if (al(e)) return function sy(e, t) { return new Ee(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (ul(e)) return function iy(e, t) { return Rt(e).pipe(wl(t), vl(t)) }(e, t); if (cl(e)) return _l(e, t); if (hl(e)) return function ay(e, t) { return new Ee(n => { let r; return Ot(n, t, () => { r = e[fl](), Ot(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => X(r?.return) && r.return() }) }(e, t); if (gl(e)) return function uy(e, t) { return _l(pl(e), t) }(e, t) } throw dl(e) }(e, t) : Rt(e) } function Vi(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new Qn({ next: () => { r.unsubscribe(), e() } }); return Rt(t(...n)).subscribe(r) } function W(e) { for (let t in e) if (e[t] === W) return t; throw Error("Could not find renamed property on target object.") } function q(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(q).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function Ui(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const fy = W({ __forward_ref__: W }); function zi(e) { return e.__forward_ref__ = zi, e.toString = function () { return q(this()) }, e } function S(e) { return function Gi(e) { return "function" == typeof e && e.hasOwnProperty(fy) && e.__forward_ref__ === zi }(e) ? e() : e } function Wi(e) { return e && !!e.\u0275providers } const Cl = "https://g.co/ng/security#xss"; class C extends Error { constructor(t, n) { super(to(t, n)), this.code = t } } function to(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t.trim() : ""}` } function N(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function no(e, t) { throw new C(-201, !1) } function $e(e, t) { null == e && function U(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function G(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Gt(e) { return { providers: e.providers || [], imports: e.imports || [] } } function ro(e) { return bl(e, oo) || bl(e, Sl) } function bl(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Il(e) { return e && (e.hasOwnProperty(qi) || e.hasOwnProperty(vy)) ? e[qi] : null } const oo = W({ \u0275prov: W }), qi = W({ \u0275inj: W }), Sl = W({ ngInjectableDef: W }), vy = W({ ngInjectorDef: W }); var T = (() => ((T = T || {})[T.Default = 0] = "Default", T[T.Host = 1] = "Host", T[T.Self = 2] = "Self", T[T.SkipSelf = 4] = "SkipSelf", T[T.Optional = 8] = "Optional", T))(); let Ki; function Ue(e) { const t = Ki; return Ki = e, t } function Ml(e, t, n) { const r = ro(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & T.Optional ? null : void 0 !== t ? t : void no(q(e)) } const Y = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), tr = {}, Yi = "__NG_DI_FLAG__", io = "ngTempTokenPath", _y = "ngTokenPath", Ey = /\n/gm, Cy = "\u0275", Tl = "__source"; let nr; function un(e) { const t = nr; return nr = e, t } function by(e, t = T.Default) { if (void 0 === nr) throw new C(-203, !1); return null === nr ? Ml(e, void 0, t) : nr.get(e, t & T.Optional ? null : void 0, t) } function L(e, t = T.Default) { return (function wy() { return Ki }() || by)(S(e), t) } function rr(e, t = T.Default) { return L(e, so(t)) } function so(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function Zi(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = S(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new C(900, !1); let o, i = T.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = Iy(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(L(o, i)) } else t.push(L(r)) } return t } function or(e, t) { return e[Yi] = t, e.prototype[Yi] = t, e } function Iy(e) { return e[Yi] } function yt(e) { return { toString: e }.toString() } var st = (() => ((st = st || {})[st.OnPush = 0] = "OnPush", st[st.Default = 1] = "Default", st))(), at = (() => { return (e = at || (at = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", at; var e })(); const Dt = {}, B = [], ao = W({ \u0275cmp: W }), Xi = W({ \u0275dir: W }), Qi = W({ \u0275pipe: W }), Nl = W({ \u0275mod: W }), vt = W({ \u0275fac: W }), ir = W({ __NG_ELEMENT_ID__: W }); let Ty = 0; function Ji(e) { return yt(() => { const t = xl(e), n = { ...t, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === st.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, data: e.data || {}, encapsulation: e.encapsulation || at.Emulated, id: "c" + Ty++, styles: e.styles || B, _: null, schemas: e.schemas || null, tView: null }; Fl(n); const r = e.dependencies; return n.directiveDefs = uo(r, !1), n.pipeDefs = uo(r, !0), n }) } function Ny(e) { return z(e) || me(e) } function Py(e) { return null !== e } function ln(e) { return yt(() => ({ type: e.type, bootstrap: e.bootstrap || B, declarations: e.declarations || B, imports: e.imports || B, exports: e.exports || B, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function Pl(e, t) { if (null == e) return Dt; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } function ze(e) { return yt(() => { const t = xl(e); return Fl(t), t }) } function z(e) { return e[ao] || null } function me(e) { return e[Xi] || null } function Ne(e) { return e[Qi] || null } function xl(e) { const t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, exportAs: e.exportAs || null, standalone: !0 === e.standalone, selectors: e.selectors || B, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: Pl(e.inputs, t), outputs: Pl(e.outputs) } } function Fl(e) { e.features?.forEach(t => t(e)) } function uo(e, t) { if (!e) return null; const n = t ? Ne : Ny; return () => ("function" == typeof e ? e() : e).map(r => n(r)).filter(Py) } const wt = 0, E = 1, F = 2, ee = 3, Ze = 4, Wt = 5, ye = 6, cn = 7, ne = 8, lo = 9, co = 10, O = 11, es = 12, ar = 13, Rl = 14, dn = 15, De = 16, ur = 17, fn = 18, ut = 19, lr = 20, Ol = 21, Z = 22, ts = 1, kl = 2, fo = 7, ho = 8, hn = 9, Ce = 10; function je(e) { return Array.isArray(e) && "object" == typeof e[ts] } function Xe(e) { return Array.isArray(e) && !0 === e[ts] } function ns(e) { return 0 != (4 & e.flags) } function cr(e) { return e.componentOffset > -1 } function po(e) { return 1 == (1 & e.flags) } function Qe(e) { return !!e.template } function Fy(e) { return 0 != (256 & e[F]) } function qt(e, t) { return e.hasOwnProperty(vt) ? e[vt] : null } class ky { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function Hl(e) { return e.type.prototype.ngOnChanges && (e.setInput = jy), Ly } function Ly() { const e = Vl(this), t = e?.current; if (t) { const n = e.previous; if (n === Dt) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function jy(e, t, n, r) { const o = this.declaredInputs[n], i = Vl(e) || function Hy(e, t) { return e[Bl] = t }(e, { previous: Dt, current: null }), s = i.current || (i.current = {}), a = i.previous, u = a[o]; s[o] = new ky(u && u.currentValue, t, a === Dt), e[r] = t } const Bl = "__ngSimpleChanges__"; function Vl(e) { return e[Bl] || null } const Ge = function (e, t, n) { }; function pe(e) { for (; Array.isArray(e);)e = e[wt]; return e } function He(e, t) { return pe(t[e.index]) } function zl(e, t) { return e.data[t] } function Pe(e, t) { const n = t[e]; return je(n) ? n : n[wt] } function yo(e) { return 64 == (64 & e[F]) } function Lt(e, t) { return null == t ? null : e[t] } function Gl(e) { e[fn] = 0 } function os(e, t) { e[Wt] += t; let n = e, r = e[ee]; for (; null !== r && (1 === t && 1 === n[Wt] || -1 === t && 0 === n[Wt]);)r[Wt] += t, n = r, r = r[ee] } const P = { lFrame: tc(null), bindingsEnabled: !0 }; function ql() { return P.bindingsEnabled } function y() { return P.lFrame.lView } function H() { return P.lFrame.tView } function ge() { let e = Kl(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Kl() { return P.lFrame.currentTNode } function lt(e, t) { const n = P.lFrame; n.currentTNode = e, n.isParent = t } function is() { return P.lFrame.isParent } function gn() { return P.lFrame.bindingIndex++ } function eD(e, t) { const n = P.lFrame; n.bindingIndex = n.bindingRootIndex = e, as(t) } function as(e) { P.lFrame.currentDirectiveIndex = e } function ls(e) { P.lFrame.currentQueryIndex = e } function nD(e) { const t = e[E]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[ye] : null } function Jl(e, t, n) { if (n & T.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & T.Host || (o = nD(i), null === o || (i = i[dn], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = P.lFrame = ec(); return r.currentTNode = t, r.lView = e, !0 } function cs(e) { const t = ec(), n = e[E]; P.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function ec() { const e = P.lFrame, t = null === e ? null : e.child; return null === t ? tc(e) : t } function tc(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function nc() { const e = P.lFrame; return P.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const rc = nc; function ds() { const e = nc(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function Ie() { return P.lFrame.selectedIndex } function Kt(e) { P.lFrame.selectedIndex = e } function Do(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: l, ngOnDestroy: c } = i; s && (e.contentHooks ?? (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks ?? (e.contentHooks = [])).push(n, a), (e.contentCheckHooks ?? (e.contentCheckHooks = [])).push(n, a)), u && (e.viewHooks ?? (e.viewHooks = [])).push(-n, u), l && ((e.viewHooks ?? (e.viewHooks = [])).push(n, l), (e.viewCheckHooks ?? (e.viewCheckHooks = [])).push(n, l)), null != c && (e.destroyHooks ?? (e.destroyHooks = [])).push(n, c) } } function vo(e, t, n) { oc(e, t, 3, n) } function wo(e, t, n, r) { (3 & e[F]) === n && oc(e, t, n, r) } function fs(e, t) { let n = e[F]; (3 & n) === t && (n &= 2047, n += 1, e[F] = n) } function oc(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[fn] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[fn] += 65536), (a < i || -1 == i) && (dD(e, n, t, u), e[fn] = (4294901760 & e[fn]) + u + 2), u++ } function dD(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[F] >> 11 < e[fn] >> 16 && (3 & e[F]) === t) { e[F] += 2048, Ge(4, a, i); try { i.call(a) } finally { Ge(5, a, i) } } } else { Ge(4, a, i); try { i.call(a) } finally { Ge(5, a, i) } } } const mn = -1; class fr { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function ps(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; sc(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function ic(e) { return 3 === e || 4 === e || 6 === e } function sc(e) { return 64 === e.charCodeAt(0) } function hr(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || ac(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function ac(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function uc(e) { return e !== mn } function _o(e) { return 32767 & e } function Eo(e, t) { let n = function gD(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[dn], n--; return r } let gs = !0; function Co(e) { const t = gs; return gs = e, t } const lc = 255, cc = 5; let mD = 0; const ct = {}; function bo(e, t) { const n = dc(e, t); if (-1 !== n) return n; const r = t[E]; r.firstCreatePass && (e.injectorIndex = t.length, ms(r.data, e), ms(t, null), ms(r.blueprint, null)); const o = ys(e, t), i = e.injectorIndex; if (uc(o)) { const s = _o(o), a = Eo(o, t), u = a[E].data; for (let l = 0; l < 8; l++)t[i + l] = a[s + l] | u[s + l] } return t[i + 8] = o, i } function ms(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function dc(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function ys(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = Dc(o), null === r) return mn; if (n++, o = o[dn], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return mn } function Ds(e, t, n) { !function yD(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(ir) && (r = n[ir]), null == r && (r = n[ir] = mD++); const o = r & lc; t.data[e + (o >> cc)] |= 1 << o }(e, t, n) } function fc(e, t, n) { if (n & T.Optional || void 0 !== e) return e; no() } function hc(e, t, n, r) { if (n & T.Optional && void 0 === r && (r = null), !(n & (T.Self | T.Host))) { const o = e[lo], i = Ue(void 0); try { return o ? o.get(t, r, n & T.Optional) : Ml(t, r, n & T.Optional) } finally { Ue(i) } } return fc(r, 0, n) } function pc(e, t, n, r = T.Default, o) { if (null !== e) { if (1024 & t[F]) { const s = function CD(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 1024 & s[F] && !(256 & s[F]);) { const a = gc(i, s, n, r | T.Self, ct); if (a !== ct) return a; let u = i.parent; if (!u) { const l = s[Ol]; if (l) { const c = l.get(n, ct, r); if (c !== ct) return c } u = Dc(s), s = s[dn] } i = u } return o }(e, t, n, r, ct); if (s !== ct) return s } const i = gc(e, t, n, r, ct); if (i !== ct) return i } return hc(t, n, r, o) } function gc(e, t, n, r, o) { const i = function wD(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(ir) ? e[ir] : void 0; return "number" == typeof t ? t >= 0 ? t & lc : _D : t }(n); if ("function" == typeof i) { if (!Jl(t, e, r)) return r & T.Host ? fc(o, 0, r) : hc(t, n, r, o); try { const s = i(r); if (null != s || r & T.Optional) return s; no() } finally { rc() } } else if ("number" == typeof i) { let s = null, a = dc(e, t), u = mn, l = r & T.Host ? t[De][ye] : null; for ((-1 === a || r & T.SkipSelf) && (u = -1 === a ? ys(e, t) : t[a + 8], u !== mn && yc(r, !1) ? (s = t[E], a = _o(u), t = Eo(u, t)) : a = -1); -1 !== a;) { const c = t[E]; if (mc(i, a, c.data)) { const d = vD(a, t, n, s, r, l); if (d !== ct) return d } u = t[a + 8], u !== mn && yc(r, t[E].data[a + 8] === l) && mc(i, a, t) ? (s = c, a = _o(u), t = Eo(u, t)) : a = -1 } } return o } function vD(e, t, n, r, o, i) { const s = t[E], a = s.data[e + 8], c = function Io(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && Qe(h) && h.type === n) return u } return null }(a, s, n, null == r ? cr(a) && gs : r != s && 0 != (3 & a.type), o & T.Host && i === a); return null !== c ? Yt(t, s, c, a) : ct } function Yt(e, t, n, r) { let o = e[n]; const i = t.data; if (function fD(e) { return e instanceof fr }(o)) { const s = o; s.resolving && function hy(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new C(-200, `Circular dependency in DI detected for ${e}${n}`) }(function $(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : N(e) }(i[n])); const a = Co(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? Ue(s.injectImpl) : null; Jl(e, r, T.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function cD(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = Hl(t); (n.preOrderHooks ?? (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks ?? (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks ?? (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== u && Ue(u), Co(a), s.resolving = !1, rc() } } return o } function mc(e, t, n) { return !!(n[t + (e >> cc)] & 1 << e) } function yc(e, t) { return !(e & T.Self || e & T.Host && t) } class yn { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return pc(this._tNode, this._lView, t, so(r), n) } } function _D() { return new yn(ge(), y()) } function Dc(e) { const t = e[E], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[ye] : null } const vn = "__parameters__"; function _n(e, t, n) { return yt(() => { const r = function _s(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, l, c) { const d = u.hasOwnProperty(vn) ? u[vn] : Object.defineProperty(u, vn, { value: [] })[vn]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class A { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = G({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Zt(e, t) { e.forEach(n => Array.isArray(n) ? Zt(n, t) : t(n)) } function wc(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function So(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } const To = or(_n("Optional"), 8), Ao = or(_n("SkipSelf"), 4); var xe = (() => ((xe = xe || {})[xe.Important = 1] = "Important", xe[xe.DashCase = 2] = "DashCase", xe))(); const As = new Map; let YD = 0; const Ps = "__ngContext__"; function ve(e, t) { je(t) ? (e[Ps] = t[lr], function XD(e) { As.set(e[lr], e) }(t)) : e[Ps] = t } let xs; function Fs(e, t) { return xs(e, t) } function wr(e) { const t = e[ee]; return Xe(t) ? t[ee] : t } function Rs(e) { return Vc(e[ar]) } function Os(e) { return Vc(e[Ze]) } function Vc(e) { for (; null !== e && !Xe(e);)e = e[Ze]; return e } function bn(e, t, n, r, o) { if (null != r) { let i, s = !1; Xe(r) ? i = r : je(r) && (s = !0, r = r[wt]); const a = pe(r); 0 === e && null !== n ? null == o ? qc(t, n, a) : Xt(t, n, a, o || null, !0) : 1 === e && null !== n ? Xt(t, n, a, o || null, !0) : 2 === e ? function $s(e, t, n) { const r = xo(e, t); r && function yv(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function wv(e, t, n, r, o) { const i = n[fo]; i !== pe(n) && bn(t, e, r, i, o); for (let a = Ce; a < n.length; a++) { const u = n[a]; _r(u[E], u, e, t, r, i) } }(t, e, i, n, o) } } function Ls(e, t, n) { return e.createElement(t, n) } function Uc(e, t) { const n = e[hn], r = n.indexOf(t), o = t[ee]; 512 & t[F] && (t[F] &= -513, os(o, -1)), n.splice(r, 1) } function js(e, t) { if (e.length <= Ce) return; const n = Ce + t, r = e[n]; if (r) { const o = r[ur]; null !== o && o !== e && Uc(o, r), t > 0 && (e[n - 1][Ze] = r[Ze]); const i = So(e, Ce + t); !function lv(e, t) { _r(e, t, t[O], 2, null, null), t[wt] = null, t[ye] = null }(r[E], r); const s = i[ut]; null !== s && s.detachView(i[E]), r[ee] = null, r[Ze] = null, r[F] &= -65 } return r } function zc(e, t) { if (!(128 & t[F])) { const n = t[O]; n.destroyNode && _r(e, t, n, 3, null, null), function fv(e) { let t = e[ar]; if (!t) return Hs(e[E], e); for (; t;) { let n = null; if (je(t)) n = t[ar]; else { const r = t[Ce]; r && (n = r) } if (!n) { for (; t && !t[Ze] && t !== e;)je(t) && Hs(t[E], t), t = t[ee]; null === t && (t = e), je(t) && Hs(t[E], t), n = t && t[Ze] } t = n } }(t) } } function Hs(e, t) { if (!(128 & t[F])) { t[F] &= -65, t[F] |= 128, function mv(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof fr)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; Ge(4, a, u); try { u.call(a) } finally { Ge(5, a, u) } } else { Ge(4, o, i); try { i.call(o) } finally { Ge(5, o, i) } } } } }(e, t), function gv(e, t) { const n = e.cleanup, r = t[cn]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 3]; s >= 0 ? r[o = s]() : r[o = -s].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); t[cn] = null } }(e, t), 1 === t[E].type && t[O].destroy(); const n = t[ur]; if (null !== n && Xe(t[ee])) { n !== t[ee] && Uc(n, t); const r = t[ut]; null !== r && r.detachView(e) } !function QD(e) { As.delete(e[lr]) }(t) } } function Gc(e, t, n) { return function Wc(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[wt]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === at.None || i === at.Emulated) return null } return He(r, n) } }(e, t.parent, n) } function Xt(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function qc(e, t, n) { e.appendChild(t, n) } function Kc(e, t, n, r, o) { null !== r ? Xt(e, t, n, r, o) : qc(e, t, n) } function xo(e, t) { return e.parentNode(t) } let Bs, Gs, Xc = function Zc(e, t, n) { return 40 & e.type ? He(e, n) : null }; function Fo(e, t, n, r) { const o = Gc(e, r, t), i = t[O], a = function Yc(e, t, n) { return Xc(e, t, n) }(r.parent || t[ye], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Kc(i, o, n[u], a, !1); else Kc(i, o, n, a, !1); void 0 !== Bs && Bs(i, r, t, n, o) } function Ro(e, t) { if (null !== t) { const n = t.type; if (3 & n) return He(t, e); if (4 & n) return Vs(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return Ro(e, r); { const o = e[t.index]; return Xe(o) ? Vs(-1, o) : pe(o) } } if (32 & n) return Fs(t, e)() || pe(e[t.index]); { const r = Jc(e, t); return null !== r ? Array.isArray(r) ? r[0] : Ro(wr(e[De]), r) : Ro(e, t.next) } } return null } function Jc(e, t) { return null !== t ? e[De][ye].projection[t.projection] : null } function Vs(e, t) { const n = Ce + e + 1; if (n < t.length) { const r = t[n], o = r[E].firstChild; if (null !== o) return Ro(r, o) } return t[fo] } function Us(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && ve(pe(a), r), n.flags |= 2), 32 != (32 & n.flags)) if (8 & u) Us(e, t, n.child, r, o, i, !1), bn(t, e, o, a, i); else if (32 & u) { const l = Fs(n, r); let c; for (; c = l();)bn(t, e, o, c, i); bn(t, e, o, a, i) } else 16 & u ? ed(e, t, r, n, o, i) : bn(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function _r(e, t, n, r, o, i) { Us(n, r, e.firstChild, t, o, i, !1) } function ed(e, t, n, r, o, i) { const s = n[De], u = s[ye].projection[r.projection]; if (Array.isArray(u)) for (let l = 0; l < u.length; l++)bn(t, e, o, u[l], i); else Us(e, t, u, s[ee], o, i, !0) } function td(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function nd(e, t, n) { const { mergedAttrs: r, classes: o, styles: i } = n; null !== r && ps(e, t, r), null !== o && td(e, t, o), null !== i && function Ev(e, t, n) { e.setAttribute(t, "style", n) }(e, t, i) } class ad { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Cl})` } } const kv = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; var ae = (() => ((ae = ae || {})[ae.NONE = 0] = "NONE", ae[ae.HTML = 1] = "HTML", ae[ae.STYLE = 2] = "STYLE", ae[ae.SCRIPT = 3] = "SCRIPT", ae[ae.URL = 4] = "URL", ae[ae.RESOURCE_URL = 5] = "RESOURCE_URL", ae))(); function Xs(e) { const t = function br() { const e = y(); return e && e[es] }(); return t ? t.sanitize(ae.URL, e) || "" : function Er(e, t) { const n = function xv(e) { return e instanceof ad && e.getTypeName() || null }(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see ${Cl})`) } return n === t }(e, "URL") ? function jt(e) { return e instanceof ad ? e.changingThisBreaksApplicationSecurity : e }(e) : function qs(e) { return (e = String(e)).match(kv) ? e : "unsafe:" + e }(N(e)) } const gd = new A("ENVIRONMENT_INITIALIZER"), md = new A("INJECTOR", -1), yd = new A("INJECTOR_DEF_TYPES"); class Dd { get(t, n = tr) { if (n === tr) { const r = new Error(`NullInjectorError: No provider for ${q(t)}!`); throw r.name = "NullInjectorError", r } return n } } function Xv(...e) { return { \u0275providers: vd(0, e), \u0275fromNgModule: !0 } } function vd(e, ...t) { const n = [], r = new Set; let o; return Zt(t, i => { const s = i; Qs(s, n, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && wd(o, n), n } function wd(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; Js(o, i => { t.push(i) }) } } function Qs(e, t, n, r) { if (!(e = S(e))) return !1; let o = null, i = Il(e); const s = !i && z(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = Il(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const l of u) Qs(l, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let l; r.add(o); try { Zt(i.imports, c => { Qs(c, t, n, r) && (l || (l = []), l.push(c)) }) } finally { } void 0 !== l && wd(l, t) } if (!a) { const l = qt(o) || (() => new o); t.push({ provide: o, useFactory: l, deps: B }, { provide: yd, useValue: o, multi: !0 }, { provide: gd, useValue: () => L(o), multi: !0 }) } const u = i.providers; null == u || a || Js(u, c => { t.push(c) }) } } return o !== e && void 0 !== e.providers } function Js(e, t) { for (let n of e) Wi(n) && (n = n.\u0275providers), Array.isArray(n) ? Js(n, t) : t(n) } const Qv = W({ provide: String, useValue: W }); function ea(e) { return null !== e && "object" == typeof e && Qv in e } function Qt(e) { return "function" == typeof e } const ta = new A("Set Injector scope."), jo = {}, ew = {}; let na; function Ho() { return void 0 === na && (na = new Dd), na } class Jt { } class Cd extends Jt { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, oa(t, s => this.processProvider(s)), this.records.set(md, Sn(void 0, this)), o.has("environment") && this.records.set(Jt, Sn(void 0, this)); const i = this.records.get(ta); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(yd.multi, B, T.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } runInContext(t) { this.assertNotDestroyed(); const n = un(this), r = Ue(void 0); try { return t() } finally { un(n), Ue(r) } } get(t, n = tr, r = T.Default) { this.assertNotDestroyed(), r = so(r); const o = un(this), i = Ue(void 0); try { if (!(r & T.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = function iw(e) { return "function" == typeof e || "object" == typeof e && e instanceof A }(t) && ro(t); a = u && this.injectableDefInScope(u) ? Sn(ra(t), jo) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & T.Self ? Ho() : this.parent).get(t, n = r & T.Optional && n === tr ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[io] = s[io] || []).unshift(q(t)), o) throw s; return function Sy(e, t, n, r) { const o = e[io]; throw t[Tl] && o.unshift(t[Tl]), e.message = function My(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && e.charAt(1) == Cy ? e.slice(2) : e; let o = q(t); if (Array.isArray(t)) o = t.map(q).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : q(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(Ey, "\n  ")}` }("\n" + e.message, o, n, r), e[_y] = o, e[io] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { Ue(i), un(o) } } resolveInjectorInitializers() { const t = un(this), n = Ue(void 0); try { const r = this.get(gd.multi, B, T.Self); for (const o of r) o() } finally { un(t), Ue(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(q(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new C(205, !1) } processProvider(t) { let n = Qt(t = S(t)) ? t : S(t && t.provide); const r = function nw(e) { return ea(e) ? Sn(void 0, e.useValue) : Sn(function bd(e, t, n) { let r; if (Qt(e)) { const o = S(e); return qt(o) || ra(o) } if (ea(e)) r = () => S(e.useValue); else if (function Ed(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...Zi(e.deps || [])); else if (function _d(e) { return !(!e || !e.useExisting) }(e)) r = () => L(S(e.useExisting)); else { const o = S(e && (e.useClass || e.provide)); if (!function rw(e) { return !!e.deps }(e)) return qt(o) || ra(o); r = () => new o(...Zi(e.deps)) } return r }(e), jo) }(t); if (Qt(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = Sn(void 0, jo, !0), o.factory = () => Zi(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === jo && (n.value = ew, n.value = n.factory()), "object" == typeof n.value && n.value && function ow(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = S(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function ra(e) { const t = ro(e), n = null !== t ? t.factory : qt(e); if (null !== n) return n; if (e instanceof A) throw new C(204, !1); if (e instanceof Function) return function tw(e) { const t = e.length; if (t > 0) throw function mr(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new C(204, !1); const n = function Dy(e) { return e && (e[oo] || e[Sl]) || null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new C(204, !1) } function Sn(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function oa(e, t) { for (const n of e) Array.isArray(n) ? oa(n, t) : n && Wi(n) ? oa(n.\u0275providers, t) : t(n) } class sw { } class Id { } class uw { resolveComponentFactory(t) { throw function aw(e) { const t = Error(`No component factory found for ${q(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let Bo = (() => { class e { } return e.NULL = new uw, e })(); function lw() { return Mn(ge(), y()) } function Mn(e, t) { return new Tn(He(e, t)) } let Tn = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = lw, e })(); class Md { } let Td = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => function dw() { const e = y(), n = Pe(ge().index, e); return (je(n) ? n : e)[O] }(), e })(), fw = (() => { class e { } return e.\u0275prov = G({ token: e, providedIn: "root", factory: () => null }), e })(); class ia { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const hw = new ia("15.2.10"), sa = {}, aa = "ngOriginalError"; function ua(e) { return e[aa] } class An { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && ua(t); for (; n && ua(n);)n = ua(n); return n || null } } function Nd(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const Pd = "ng-template"; function bw(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (n && "class" === i && -1 !== Nd(s.toLowerCase(), t, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function xd(e) { return 4 === e.type && e.value !== Pd } function Iw(e, t, n) { return t === (4 !== e.type || n ? e.value : Pd) } function Sw(e, t, n) { let r = 4; const o = e.attrs || [], i = function Aw(e) { for (let t = 0; t < e.length; t++)if (ic(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !Iw(e, u, n) || "" === u && 1 === t.length) { if (Je(r)) return !1; s = !0 } } else { const l = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!bw(e.attrs, l, n)) { if (Je(r)) return !1; s = !0 } continue } const d = Mw(8 & r ? "class" : u, o, xd(e), n); if (-1 === d) { if (Je(r)) return !1; s = !0; continue } if ("" !== l) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Nd(h, l, 0) || 2 & r && l !== f) { if (Je(r)) return !1; s = !0 } } } } else { if (!s && !Je(r) && !Je(u)) return !1; if (s && Je(u)) continue; s = !1, r = u | 1 & r } } return Je(r) || s } function Je(e) { return 0 == (1 & e) } function Mw(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function Nw(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function Fd(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (Sw(e, t[r], n)) return !0; return !1 } function Rd(e, t) { return e ? ":not(" + t.trim() + ")" : t } function xw(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !Je(s) && (t += Rd(i, o), o = ""), r = s, i = i || !Je(r); n++ } return "" !== o && (t += Rd(i, o)), t } const x = {}; function en(e) { Od(H(), y(), Ie() + e, !1) } function Od(e, t, n, r) { if (!r) if (3 == (3 & t[F])) { const i = e.preOrderCheckHooks; null !== i && vo(t, i, n) } else { const i = e.preOrderHooks; null !== i && wo(t, i, 0, n) } Kt(n) } function Hd(e, t = null, n = null, r) { const o = Bd(e, t, n, r); return o.resolveInjectorInitializers(), o } function Bd(e, t = null, n = null, r, o = new Set) { const i = [n || B, Xv(e)]; return r = r || ("object" == typeof e ? void 0 : q(e)), new Cd(i, t || Ho(), r || null, o) } let tn = (() => { class e { static create(n, r) { if (Array.isArray(n)) return Hd({ name: "" }, r, n, ""); { const o = n.name ?? ""; return Hd({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = tr, e.NULL = new Dd, e.\u0275prov = G({ token: e, providedIn: "any", factory: () => L(md) }), e.__NG_ELEMENT_ID__ = -1, e })(); function k(e, t = T.Default) { const n = y(); return null === n ? L(e, t) : pc(ge(), n, S(e), t) } function qd(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; ls(n[r]), s.contentQueries(2, t[i], i) } } } function $o(e, t, n, r, o, i, s, a, u, l, c) { const d = t.blueprint.slice(); return d[wt] = o, d[F] = 76 | r, (null !== c || e && 1024 & e[F]) && (d[F] |= 1024), Gl(d), d[ee] = d[dn] = e, d[ne] = n, d[co] = s || e && e[co], d[O] = a || e && e[O], d[es] = u || e && e[es] || null, d[lo] = l || e && e[lo] || null, d[ye] = i, d[lr] = function ZD() { return YD++ }(), d[Ol] = c, d[De] = 2 == t.type ? e[De] : d, d } function xn(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function ha(e, t, n, r, o) { const i = Kl(), s = is(), u = e.data[t] = function i_(e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u, u.prev = i)), u }(e, t, n, r, o), function Jy() { return P.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function dr() { const e = P.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return lt(i, !0), i } function Ir(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function pa(e, t, n) { cs(t); try { const r = e.viewQuery; null !== r && Ca(1, r, n); const o = e.template; null !== o && Kd(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && qd(e, t), e.staticViewQueries && Ca(2, e.viewQuery, n); const i = e.components; null !== i && function n_(e, t) { for (let n = 0; n < t.length; n++)I_(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[F] &= -5, ds() } } function Uo(e, t, n, r) { const o = t[F]; if (128 != (128 & o)) { cs(t); try { Gl(t), function Zl(e) { return P.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && Kd(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const l = e.preOrderCheckHooks; null !== l && vo(t, l, null) } else { const l = e.preOrderHooks; null !== l && wo(t, l, 0, null), fs(t, 0) } if (function C_(e) { for (let t = Rs(e); null !== t; t = Os(t)) { if (!t[kl]) continue; const n = t[hn]; for (let r = 0; r < n.length; r++) { const o = n[r]; 512 & o[F] || os(o[ee], 1), o[F] |= 512 } } }(t), function E_(e) { for (let t = Rs(e); null !== t; t = Os(t))for (let n = Ce; n < t.length; n++) { const r = t[n], o = r[E]; yo(r) && Uo(o, r, o.template, r[ne]) } }(t), null !== e.contentQueries && qd(e, t), s) { const l = e.contentCheckHooks; null !== l && vo(t, l) } else { const l = e.contentHooks; null !== l && wo(t, l, 1), fs(t, 1) } !function e_(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) Kt(~o); else { const i = o, s = n[++r], a = n[++r]; eD(s, i), a(2, t[i]) } } } finally { Kt(-1) } }(e, t); const a = e.components; null !== a && function t_(e, t) { for (let n = 0; n < t.length; n++)b_(e, t[n]) }(t, a); const u = e.viewQuery; if (null !== u && Ca(2, u, r), s) { const l = e.viewCheckHooks; null !== l && vo(t, l) } else { const l = e.viewHooks; null !== l && wo(t, l, 2), fs(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[F] &= -41, 512 & t[F] && (t[F] &= -513, os(t[ee], -1)) } finally { ds() } } } function Kd(e, t, n, r, o) { const i = Ie(), s = 2 & r; try { Kt(-1), s && t.length > Z && Od(e, t, Z, !1), Ge(s ? 2 : 0, o), n(r, o) } finally { Kt(i), Ge(s ? 3 : 1, o) } } function ga(e, t, n) { if (ns(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } } function ma(e, t, n) { ql() && (function f_(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; cr(n) && function v_(e, t, n) { const r = He(t, e), o = Yd(n), i = e[co], s = zo(e, $o(e, o, null, n.onPush ? 32 : 16, r, t, i, i.createRenderer(r, n), null, null, null)); e[t.index] = s }(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || bo(n, t), ve(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], l = Yt(t, e, a, n); ve(l, t), null !== s && w_(0, a - o, l, u, 0, s), Qe(u) && (Pe(n.index, t)[ne] = Yt(t, e, a, n)) } }(e, t, n, He(n, t)), 64 == (64 & n.flags) && ef(e, t, n)) } function ya(e, t, n = He) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function Yd(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = Da(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function Da(e, t, n, r, o, i, s, a, u, l) { const c = Z + r, d = c + o, f = function r_(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : x); return n }(c, d), h = "function" == typeof l ? l() : l; return f[E] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: h, incompleteFirstPass: !1 } } function Xd(e, t, n, r) { for (let o in e) if (e.hasOwnProperty(o)) { n = null === n ? {} : n; const i = e[o]; null === r ? Qd(n, t, o, i) : r.hasOwnProperty(o) && Qd(n, t, r[o], i) } return n } function Qd(e, t, n, r) { e.hasOwnProperty(n) ? e[n].push(t, r) : e[n] = [t, r] } function va(e, t, n, r) { if (ql()) { const o = null === r ? null : { "": -1 }, i = function p_(e, t) { const n = e.directiveRegistry; let r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { const s = n[i]; if (Fd(t, s.selectors, !1)) if (r || (r = []), Qe(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), wa(e, t, a.length) } else r.unshift(s), wa(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, n); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && Jd(e, t, n, s, o, a), o && function g_(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new C(-301, !1); r.push(t[o], i) } } }(n, r, o) } n.mergedAttrs = hr(n.mergedAttrs, n.attrs) } function Jd(e, t, n, r, o, i) { for (let l = 0; l < r.length; l++)Ds(bo(n, t), e, r[l].type); !function y_(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t }(n, e.data.length, r.length); for (let l = 0; l < r.length; l++) { const c = r[l]; c.providersResolver && c.providersResolver(c) } let s = !1, a = !1, u = Ir(e, t, r.length, null); for (let l = 0; l < r.length; l++) { const c = r[l]; n.mergedAttrs = hr(n.mergedAttrs, c.hostAttrs), D_(e, n, t, u, c), m_(u, c, o), null !== c.contentQueries && (n.flags |= 4), (null !== c.hostBindings || null !== c.hostAttrs || 0 !== c.hostVars) && (n.flags |= 64); const d = c.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ?? (e.preOrderHooks = [])).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ?? (e.preOrderCheckHooks = [])).push(n.index), a = !0), u++ } !function s_(e, t, n) { const o = t.directiveEnd, i = e.data, s = t.attrs, a = []; let u = null, l = null; for (let c = t.directiveStart; c < o; c++) { const d = i[c], f = n ? n.get(d) : null, p = f ? f.outputs : null; u = Xd(d.inputs, c, u, f ? f.inputs : null), l = Xd(d.outputs, c, l, p); const g = null === u || null === s || xd(t) ? null : __(u, c, s); a.push(g) } null !== u && (u.hasOwnProperty("class") && (t.flags |= 8), u.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = u, t.outputs = l }(e, n, i) } function ef(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function tD() { return P.lFrame.currentDirectiveIndex }(); try { Kt(i); for (let a = r; a < o; a++) { const u = e.data[a], l = t[a]; as(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && h_(u, l) } } finally { Kt(-1), as(s) } } function h_(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function wa(e, t, n) { t.componentOffset = n, (e.components ?? (e.components = [])).push(t.index) } function m_(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; Qe(t) && (n[""] = e) } } function D_(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = qt(o.type)), s = new fr(i, Qe(o), k); e.blueprint[r] = s, n[r] = s, function c_(e, t, n, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~t.index; (function d_(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(s) != a && s.push(a), s.push(n, r, i) } }(e, t, r, Ir(e, n, o.hostVars, x), o) } function w_(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let u = 0; u < s.length;) { const l = s[u++], c = s[u++], d = s[u++]; null !== a ? r.setInput(n, d, l, c) : n[c] = d } } } function __(e, t, n) { let r = null, o = 0; for (; o < n.length;) { const i = n[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === t) { r.push(i, s[a + 1], n[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function tf(e, t, n, r) { return [e, !0, !1, t, null, 0, r, n, null, null] } function b_(e, t) { const n = Pe(t, e); if (yo(n)) { const r = n[E]; 48 & n[F] ? Uo(r, n, r.template, n[ne]) : n[Wt] > 0 && Ea(n) } } function Ea(e) { for (let r = Rs(e); null !== r; r = Os(r))for (let o = Ce; o < r.length; o++) { const i = r[o]; if (yo(i)) if (512 & i[F]) { const s = i[E]; Uo(s, i, s.template, i[ne]) } else i[Wt] > 0 && Ea(i) } const n = e[E].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = Pe(n[r], e); yo(o) && o[Wt] > 0 && Ea(o) } } function I_(e, t) { const n = Pe(t, e), r = n[E]; (function S_(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), pa(r, n, n[ne]) } function zo(e, t) { return e[ar] ? e[Rl][Ze] = t : e[ar] = t, e[Rl] = t, t } function Go(e) { for (; e;) { e[F] |= 32; const t = wr(e); if (Fy(e) && !t) return e; e = t } return null } function Wo(e, t, n, r = !0) { const o = t[co]; o.begin && o.begin(); try { Uo(e, t, e.template, n) } catch (s) { throw r && sf(t, s), s } finally { o.end && o.end() } } function Ca(e, t, n) { ls(0), t(e, n) } function nf(e) { return e[cn] || (e[cn] = []) } function rf(e) { return e.cleanup || (e.cleanup = []) } function sf(e, t) { const n = e[lo], r = n ? n.get(An, null) : null; r && r.handleError(t) } function ba(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], u = t[s], l = e.data[s]; null !== l.setInput ? l.setInput(u, o, r, a) : u[a] = o } } function It(e, t, n) { const r = function mo(e, t) { return pe(t[e]) }(t, e); !function $c(e, t, n) { e.setValue(t, n) }(e[O], r, n) } function qo(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = Ui(o, a) : 2 == i && (r = Ui(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function Ko(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(pe(i)), Xe(i)) for (let a = Ce; a < i.length; a++) { const u = i[a], l = u[E].firstChild; null !== l && Ko(u[E], u, l, r) } const s = n.type; if (8 & s) Ko(e, t, n.child, r); else if (32 & s) { const a = Fs(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = Jc(t, n); if (Array.isArray(a)) r.push(...a); else { const u = wr(t[De]); Ko(u[E], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class Sr { get rootNodes() { const t = this._lView, n = t[E]; return Ko(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[ne] } set context(t) { this._lView[ne] = t } get destroyed() { return 128 == (128 & this._lView[F]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[ee]; if (Xe(t)) { const n = t[ho], r = n ? n.indexOf(this) : -1; r > -1 && (js(t, r), So(n, r)) } this._attachedToViewContainer = !1 } zc(this._lView[E], this._lView) } onDestroy(t) { !function Zd(e, t, n, r) { const o = nf(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && rf(e).push(r, o.length - 1)) }(this._lView[E], this._lView, null, t) } markForCheck() { Go(this._cdRefInjectingView || this._lView) } detach() { this._lView[F] &= -65 } reattach() { this._lView[F] |= 64 } detectChanges() { Wo(this._lView[E], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new C(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function dv(e, t) { _r(e, t, t[O], 2, null, null) }(this._lView[E], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new C(902, !1); this._appRef = t } } class M_ extends Sr { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; Wo(t[E], t, t[ne], !1) } checkNoChanges() { } get context() { return null } } class af extends Bo { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = z(t); return new Mr(n, this.ngModule) } } function uf(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class A_ { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = so(r); const o = this.injector.get(t, sa, r); return o !== sa || n === sa ? o : this.parentInjector.get(t, n, r) } } class Mr extends Id { get inputs() { return uf(this.componentDef.inputs) } get outputs() { return uf(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function Fw(e) { return e.map(xw).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof Jt ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new A_(t, i) : t, a = s.get(Md, null); if (null === a) throw new C(407, !1); const u = s.get(fw, null), l = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function o_(e, t, n) { return e.selectRootElement(t, n === at.ShadowDom) }(l, r, this.componentDef.encapsulation) : Ls(l, c, function T_(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = Da(0, null, null, 1, 0, null, null, null, null, null), p = $o(null, h, null, f, null, null, a, l, u, s, null); let g, v; cs(p); try { const D = this.componentDef; let _, m = null; D.findHostDirectiveDefs ? (_ = [], m = new Map, D.findHostDirectiveDefs(D, _, m), _.push(D)) : _ = [D]; const b = function P_(e, t) { const n = e[E], r = Z; return e[r] = t, xn(n, r, 2, "#host", null) }(p, d), V = function x_(e, t, n, r, o, i, s, a) { const u = o[E]; !function F_(e, t, n, r) { for (const o of e) t.mergedAttrs = hr(t.mergedAttrs, o.hostAttrs); null !== t.mergedAttrs && (qo(t, t.mergedAttrs, !0), null !== n && nd(r, n, t)) }(r, e, t, s); const l = i.createRenderer(t, n), c = $o(o, Yd(n), null, n.onPush ? 32 : 16, o[e.index], e, i, l, a || null, null, null); return u.firstCreatePass && wa(u, e, r.length - 1), zo(o, c), o[e.index] = c }(b, d, D, _, p, a, l); v = zl(h, Z), d && function O_(e, t, n, r) { if (r) ps(e, n, ["ng-version", hw.full]); else { const { attrs: o, classes: i } = function Rw(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!Je(o)) break; o = i } r++ } return { attrs: t, classes: n } }(t.selectors[0]); o && ps(e, n, o), i && i.length > 0 && td(e, n, i.join(" ")) } }(l, D, d, r), void 0 !== n && function k_(e, t, n) { const r = e.projection = []; for (let o = 0; o < t.length; o++) { const i = n[o]; r.push(null != i ? Array.from(i) : null) } }(v, this.ngContentSelectors, n), g = function R_(e, t, n, r, o, i) { const s = ge(), a = o[E], u = He(s, o); Jd(a, o, s, n, null, r); for (let c = 0; c < n.length; c++)ve(Yt(o, a, s.directiveStart + c, s), o); ef(a, o, s), u && ve(u, o); const l = Yt(o, a, s.directiveStart + s.componentOffset, s); if (e[ne] = o[ne] = l, null !== i) for (const c of i) c(l, t); return ga(a, s, e), l }(V, D, _, m, p, [L_]), pa(h, p, null) } finally { ds() } return new N_(this.componentType, g, Mn(v, p), p, v) } } class N_ extends sw { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new M_(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { const i = this._rootLView; ba(i[E], i, o, t, n), Go(Pe(this._tNode.index, i)) } } get injector() { return new yn(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function L_() { const e = ge(); Do(y()[E], e) } function Yo(e) { return !!Sa(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function Sa(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function we(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function $n(e, t, n) { const r = y(); return we(r, gn(), t) && function Ve(e, t, n, r, o, i, s, a) { const u = He(t, n); let c, l = t.inputs; !a && null != l && (c = l[r]) ? (ba(e, n, c, r, o), cr(t) && function u_(e, t) { const n = Pe(t, e); 16 & n[F] || (n[F] |= 32) }(n, t.index)) : 3 & t.type && (r = function a_(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(u, r, o)) }(H(), function Q() { const e = P.lFrame; return zl(e.tView, e.selectedIndex) }(), r, e, t, r[O], n, !1), $n } function Ma(e, t, n, r, o) { const s = o ? "class" : "style"; ba(e, n, t.inputs[s], s, r) } function Se(e, t, n, r) { const o = y(), i = H(), s = Z + e, a = o[O], u = i.firstCreatePass ? function eE(e, t, n, r, o, i) { const s = t.consts, u = xn(t, e, 2, r, Lt(s, o)); return va(t, n, u, Lt(s, i)), null !== u.attrs && qo(u, u.attrs, !1), null !== u.mergedAttrs && qo(u, u.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, u), u }(s, i, o, t, n, r) : i.data[s], l = o[s] = Ls(a, t, function lD() { return P.lFrame.currentNamespace }()), c = po(u); return lt(u, !0), nd(a, l, u), 32 != (32 & u.flags) && Fo(i, o, l, u), 0 === function Gy() { return P.lFrame.elementDepthCount }() && ve(l, o), function Wy() { P.lFrame.elementDepthCount++ }(), c && (ma(i, o, u), ga(i, u, o)), null !== r && ya(o, u), Se } function Re() { let e = ge(); is() ? function ss() { P.lFrame.isParent = !1 }() : (e = e.parent, lt(e, !1)); const t = e; !function qy() { P.lFrame.elementDepthCount-- }(); const n = H(); return n.firstCreatePass && (Do(n, e), ns(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function hD(e) { return 0 != (8 & e.flags) }(t) && Ma(n, t, y(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function pD(e) { return 0 != (16 & e.flags) }(t) && Ma(n, t, y(), t.stylesWithoutHost, !1), Re } function Un(e, t, n, r) { return Se(e, t, n, r), Re(), Un } function Na(e) { return !!e && "function" == typeof e.then } const rE = function Sf(e) { return !!e && "function" == typeof e.subscribe }; function Ar(e, t, n, r) { const o = y(), i = H(), s = ge(); return function Tf(e, t, n, r, o, i, s) { const a = po(r), l = e.firstCreatePass && rf(e), c = t[ne], d = nf(t); let f = !0; if (3 & r.type || s) { const g = He(r, t), v = s ? s(g) : g, D = d.length, _ = s ? b => s(pe(b[r.index])) : r.index; let m = null; if (!s && a && (m = function oE(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[cn], u = o[i + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== m) (m.__ngLastListenerFn__ || m).__ngNextListenerFn__ = i, m.__ngLastListenerFn__ = i, f = !1; else { i = Nf(r, t, c, i, !1); const b = n.listen(v, o, i); d.push(i, b), l && l.push(o, _, D, D + 1) } } else i = Nf(r, t, c, i, !1); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let v = 0; v < g; v += 2) { const V = t[p[v]][p[v + 1]].subscribe(i), se = d.length; d.push(i, V), l && l.push(o, r.index, se, -(se + 1)) } } }(i, o, o[O], s, e, t, r), Ar } function Af(e, t, n, r) { try { return Ge(6, t, n), !1 !== n(r) } catch (o) { return sf(e, o), !1 } finally { Ge(7, t, n) } } function Nf(e, t, n, r, o) { return function i(s) { if (s === Function) return r; Go(e.componentOffset > -1 ? Pe(e.index, t) : t); let u = Af(t, n, r, s), l = i.__ngNextListenerFn__; for (; l;)u = Af(t, n, l, s) && u, l = l.__ngNextListenerFn__; return o && !1 === u && (s.preventDefault(), s.returnValue = !1), u } } function Pf(e = 1) { return function rD(e) { return (P.lFrame.contextLView = function oD(e, t) { for (; e > 0;)t = t[dn], e--; return t }(e, P.lFrame.contextLView))[ne] }(e) } function St(e, t = "") { const n = y(), r = H(), o = e + Z, i = r.firstCreatePass ? xn(r, o, 1, t, null) : r.data[o], s = n[o] = function ks(e, t) { return e.createText(t) }(n[O], t); Fo(r, n, s, i), lt(i, !1) } function Pr(e) { return ka("", e, ""), Pr } function ka(e, t, n) { const r = y(), o = function Rn(e, t, n, r) { return we(e, gn(), n) ? t + N(n) + r : x }(r, e, t, n); return o !== x && It(r, Ie(), o), ka } const Wn = "en-US"; let Ch = Wn; class qn { } class YC { } class Yh extends qn { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new af(this); const r = function Le(e, t) { const n = e[Nl] || null; if (!n && !0 === t) throw new Error(`Type ${q(e)} does not have '\u0275mod' property.`); return n }(t); this._bootstrapComponents = function bt(e) { return e instanceof Function ? e() : e }(r.bootstrap), this._r3Injector = Bd(t, n, [{ provide: qn, useValue: this }, { provide: Bo, useValue: this.componentFactoryResolver }], q(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Ua extends YC { constructor(t) { super(), this.moduleType = t } create(t) { return new Yh(this.moduleType, t) } } function Ga(e) { return t => { setTimeout(e, void 0, t) } } const Mt = class Ib extends Oi { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = Ga(i), o && (o = Ga(o)), s && (s = Ga(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof it && t.add(a), a } }; let Tt = (() => { class e { } return e.__NG_ELEMENT_ID__ = Ab, e })(); const Mb = Tt, Tb = class extends Mb { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t, n) { const r = this._declarationTContainer.tView, o = $o(this._declarationLView, r, t, 16, null, r.declTNode, null, null, null, null, n || null); o[ur] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[ut]; return null !== s && (o[ut] = s.createEmbeddedView(r)), pa(r, o, t), new Sr(o) } }; function Ab() { return function ri(e, t) { return 4 & e.type ? new Tb(t, e, Mn(e, t)) : null }(ge(), y()) } let gt = (() => { class e { } return e.__NG_ELEMENT_ID__ = Nb, e })(); function Nb() { return function cp(e, t) { let n; const r = t[e.index]; if (Xe(r)) n = r; else { let o; if (8 & e.type) o = pe(r); else { const i = t[O]; o = i.createComment(""); const s = He(e, t); Xt(i, xo(i, s), o, function Dv(e, t) { return e.nextSibling(t) }(i, s), !1) } t[e.index] = n = tf(r, t, o, e), zo(t, n) } return new up(n, e, t) }(ge(), y()) } const Pb = gt, up = class extends Pb { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return Mn(this._hostTNode, this._hostLView) } get injector() { return new yn(this._hostTNode, this._hostLView) } get parentInjector() { const t = ys(this._hostTNode, this._hostLView); if (uc(t)) { const n = Eo(t, this._hostLView), r = _o(t); return new yn(n[E].data[r + 8], n) } return new yn(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = lp(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - Ce } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = t.createEmbeddedView(n || {}, i); return this.insert(s, o), s } createComponent(t, n, r, o, i) { const s = t && !function gr(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const u = s ? t : new Mr(z(t)), l = r || this.parentInjector; if (!i && null == u.ngModule) { const f = (s ? l : this.parentInjector).get(Jt, null); f && (i = f) } const c = u.create(l, o, void 0, i); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, o = r[E]; if (function zy(e) { return Xe(e[ee]) }(r)) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[ee], f = new up(d, d[ye], d[ee]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function hv(e, t, n, r) { const o = Ce + r, i = n.length; r > 0 && (n[o - 1][Ze] = t), r < i - Ce ? (t[Ze] = n[o], wc(n, Ce + r, t)) : (n.push(t), t[Ze] = null), t[ee] = n; const s = t[ur]; null !== s && n !== s && function pv(e, t) { const n = e[hn]; t[De] !== t[ee][ee][De] && (e[kl] = !0), null === n ? e[hn] = [t] : n.push(t) }(s, t); const a = t[ut]; null !== a && a.insertView(e), t[F] |= 64 }(o, r, s, i); const a = Vs(i, s), u = r[O], l = xo(u, s[fo]); return null !== l && function cv(e, t, n, r, o, i) { r[wt] = o, r[ye] = t, _r(e, r, n, 1, o, i) }(o, s[ye], u, r, l, a), t.attachToViewContainerRef(), wc(qa(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = lp(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = js(this._lContainer, n); r && (So(qa(this._lContainer), n), zc(r[E], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = js(this._lContainer, n); return r && null != So(qa(this._lContainer), n) ? new Sr(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function lp(e) { return e[ho] } function qa(e) { return e[ho] || (e[ho] = []) } function ii(...e) { } const Rp = new A("Application Initializer"); let si = (() => { class e { constructor(n) { this.appInits = n, this.resolve = ii, this.reject = ii, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (Na(i)) n.push(i); else if (rE(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(L(Rp, 8)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const Br = new A("AppId", { providedIn: "root", factory: function Op() { return `${ru()}${ru()}${ru()}` } }); function ru() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const kp = new A("Platform Initializer"), ou = new A("Platform ID", { providedIn: "platform", factory: () => "unknown" }), At = new A("LocaleId", { providedIn: "root", factory: () => rr(At, T.Optional | T.SkipSelf) || function uI() { return typeof $localize < "u" && $localize.locale || Wn }() }), hI = (() => Promise.resolve(0))(); function iu(e) { typeof Zone > "u" ? hI.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class _e { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Mt(!1), this.onMicrotaskEmpty = new Mt(!1), this.onStable = new Mt(!1), this.onError = new Mt(!1), typeof Zone > "u") throw new C(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function pI() { let e = Y.requestAnimationFrame, t = Y.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function yI(e) { const t = () => { !function mI(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(Y, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, au(e), e.isCheckStableRunning = !0, su(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), au(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return Hp(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), Bp(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return Hp(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), Bp(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, au(e), su(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!_e.isInAngularZone()) throw new C(909, !1) } static assertNotInAngularZone() { if (_e.isInAngularZone()) throw new C(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, gI, ii, ii); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const gI = {}; function su(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function au(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function Hp(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Bp(e) { e._nesting--, su(e) } class DI { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Mt, this.onMicrotaskEmpty = new Mt, this.onStable = new Mt, this.onError = new Mt } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const Vp = new A(""), ai = new A(""); let cu, uu = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, cu || (function vI(e) { cu = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { _e.assertNotInAngularZone(), iu(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) iu(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(L(_e), L(lu), L(ai)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), lu = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return cu?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const Nt = !1; let Bt = null; const $p = new A("AllowMultipleToken"), du = new A("PlatformDestroyListeners"), wI = new A("appBootstrapListener"); function zp(e, t, n = []) { const r = `Platform: ${t}`, o = new A(r); return (i = []) => { let s = fu(); if (!s || s.injector.get($p, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function CI(e) { if (Bt && !Bt.get($p, !1)) throw new C(400, !1); Bt = e; const t = e.get(Wp); (function Up(e) { const t = e.get(kp, null); t && t.forEach(n => n()) })(e) }(function Gp(e = [], t) { return tn.create({ name: t, providers: [{ provide: ta, useValue: "platform" }, { provide: du, useValue: new Set([() => Bt = null]) }, ...e] }) }(a, r)) } return function II(e) { const t = fu(); if (!t) throw new C(401, !1); return t }() } } function fu() { return Bt?.get(Wp) ?? null } let Wp = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function Kp(e, t) { let n; return n = "noop" === e ? new DI : ("zone.js" === e ? void 0 : e) || new _e(t), n }(r?.ngZone, function qp(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: _e, useValue: o }]; return o.run(() => { const s = tn.create({ providers: i, parent: this.injector, name: n.moduleType.name }), a = n.create(s), u = a.injector.get(An, null); if (!u) throw new C(402, !1); return o.runOutsideAngular(() => { const l = o.onError.subscribe({ next: c => { u.handleError(c) } }); a.onDestroy(() => { ui(this._modules, a), l.unsubscribe() }) }), function Yp(e, t, n) { try { const r = n(); return Na(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(u, o, () => { const l = a.injector.get(si); return l.runInitializers(), l.donePromise.then(() => (function bh(e) { $e(e, "Expected localeId to be defined"), "string" == typeof e && (Ch = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(At, Wn) || Wn), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const o = Zp({}, r); return function _I(e, t, n) { const r = new Ua(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(hu); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new C(-403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new C(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(du, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(L(tn)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function Zp(e, t) { return Array.isArray(t) ? t.reduce(Zp, e) : { ...e, ...t } } let hu = (() => { class e { get destroyed() { return this._destroyed } get injector() { return this._injector } constructor(n, r, o) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new Ee(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new Ee(a => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { _e.assertNotInAngularZone(), iu(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const l = this._zone.onUnstable.subscribe(() => { _e.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { u.unsubscribe(), l.unsubscribe() } }); this.isStable = function cy(...e) { const t = Dl(e), n = function ry(e, t) { return "number" == typeof Bi(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? Rt(r[0]) : function ey(e = 1 / 0) { return eo(Ju, e) }(n)(El(r, t)) : yl }(i, s.pipe(function dy(e = {}) { const { connector: t = (() => new Oi), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, l = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, c = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return an((g, v) => { l++, !d && !c && f(); const D = u = u ?? t(); v.add(() => { l--, 0 === l && !d && !c && (a = Vi(p, o)) }), D.subscribe(v), !s && l > 0 && (s = new Qn({ next: _ => D.next(_), error: _ => { d = !0, f(), a = Vi(h, n, _), D.error(_) }, complete: () => { c = !0, f(), a = Vi(h, r), D.complete() } }), Rt(g).subscribe(s)) })(i) } }())) } bootstrap(n, r) { const o = n instanceof Id; if (!this._injector.get(si).done) { !o && function sr(e) { const t = z(e) || me(e) || Ne(e); return null !== t && t.standalone }(n); throw new C(405, Nt) } let s; s = o ? n : this._injector.get(Bo).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function EI(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(qn), l = s.create(tn.NULL, [], r || s.selector, a), c = l.location.nativeElement, d = l.injector.get(Vp, null); return d?.registerApplication(c), l.onDestroy(() => { this.detachView(l.hostView), ui(this.components, l), d?.unregisterApplication(c) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new C(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; ui(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n); const r = this._injector.get(wI, []); r.push(...this._bootstrapListeners), r.forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => ui(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new C(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e)(L(_e), L(Jt), L(An)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function ui(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class tg { constructor() { } supports(t) { return Yo(t) } create(t) { return new OI(t) } } const RI = (e, t) => t; class OI { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || RI } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < rg(r, o, i) ? n : r, a = rg(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const l = a - o, c = u - o; if (l != c) { for (let f = 0; f < l; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < l && (i[f] = h + 1) } i[s.previousIndex] = c - l } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !Yo(t)) throw new C(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function K_(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Symbol.iterator](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new kI(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new ng), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new ng), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class kI { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class LI { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class ng { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new LI, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function rg(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } class og { constructor() { } supports(t) { return t instanceof Map || Sa(t) } create() { return new jI } } class jI { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let n; for (n = this._mapHead; null !== n; n = n._next)t(n) } forEachPreviousItem(t) { let n; for (n = this._previousMapHead; null !== n; n = n._nextPrevious)t(n) } forEachChangedItem(t) { let n; for (n = this._changesHead; null !== n; n = n._nextChanged)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } diff(t) { if (t) { if (!(t instanceof Map || Sa(t))) throw new C(900, !1) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(t, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { const i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, n) { if (t) { const r = t._prev; return n._next = t, n._prev = r, t._prev = n, r && (r._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(t, n) { if (this._records.has(t)) { const o = this._records.get(t); this._maybeAddToChanges(o, n); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new HI(t); return this._records.set(t, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, n) { Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, n) { t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(r => n(t[r], r)) } } class HI { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function ig() { return new di([new tg]) } let di = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || ig()), deps: [[e, new Ao, new To]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new C(901, !1) } } return e.\u0275prov = G({ token: e, providedIn: "root", factory: ig }), e })(); function sg() { return new Vr([new og]) } let Vr = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || sg()), deps: [[e, new Ao, new To]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (r) return r; throw new C(901, !1) } } return e.\u0275prov = G({ token: e, providedIn: "root", factory: sg }), e })(); const $I = zp(null, "core", []); let UI = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(L(hu)) }, e.\u0275mod = ln({ type: e }), e.\u0275inj = Gt({}), e })(), Du = null; function fi() { return Du } class WI { } const mt = new A("DocumentToken"); function mg(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } const Tu = /\s+/, yg = []; let Dg = (() => { class e { constructor(n, r, o, i) { this._iterableDiffers = n, this._keyValueDiffers = r, this._ngEl = o, this._renderer = i, this.initialClasses = yg, this.stateMap = new Map } set klass(n) { this.initialClasses = null != n ? n.trim().split(Tu) : yg } set ngClass(n) { this.rawClass = "string" == typeof n ? n.trim().split(Tu) : n } ngDoCheck() { for (const r of this.initialClasses) this._updateState(r, !0); const n = this.rawClass; if (Array.isArray(n) || n instanceof Set) for (const r of n) this._updateState(r, !0); else if (null != n) for (const r of Object.keys(n)) this._updateState(r, Boolean(n[r])); this._applyStateDiff() } _updateState(n, r) { const o = this.stateMap.get(n); void 0 !== o ? (o.enabled !== r && (o.changed = !0, o.enabled = r), o.touched = !0) : this.stateMap.set(n, { enabled: r, changed: !0, touched: !0 }) } _applyStateDiff() { for (const n of this.stateMap) { const r = n[0], o = n[1]; o.changed ? (this._toggleClass(r, o.enabled), o.changed = !1) : o.touched || (o.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)), o.touched = !1 } } _toggleClass(n, r) { (n = n.trim()).length > 0 && n.split(Tu).forEach(o => { r ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } } return e.\u0275fac = function (n) { return new (n || e)(k(di), k(Vr), k(Tn), k(Td)) }, e.\u0275dir = ze({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), e })(); class F0 { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let _g = (() => { class e { set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new F0(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), Eg(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { Eg(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(k(gt), k(Tt), k(di)) }, e.\u0275dir = ze({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function Eg(e, t) { e.context.$implicit = t.item } let aS = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = ln({ type: e }), e.\u0275inj = Gt({}), e })(); class Tg { } class jS extends WI { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class Ou extends jS { static makeCurrent() { !function GI(e) { Du || (Du = e) }(new Ou) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function HS() { return Gr = Gr || document.querySelector("base"), Gr ? Gr.getAttribute("href") : null }(); return null == n ? null : function BS(e) { bi = bi || document.createElement("a"), bi.setAttribute("href", e); const t = bi.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { Gr = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return mg(document.cookie, t) } } let bi, Gr = null; const Fg = new A("TRANSITION_ID"), $S = [{ provide: Rp, useFactory: function VS(e, t, n) { return () => { n.get(si).donePromise.then(() => { const r = fi(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [Fg, mt, tn], multi: !0 }]; let zS = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const Ii = new A("EventManagerPlugins"); let Si = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => { o.manager = this }), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(L(Ii), L(_e)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); class Rg { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = fi().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let Og = (() => { class e { constructor() { this.usageCount = new Map } addStyles(n) { for (const r of n) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(n) { for (const r of n) 0 === this.changeUsageCount(r, -1) && this.onStyleRemoved(r) } onStyleRemoved(n) { } onStyleAdded(n) { } getAllStyles() { return this.usageCount.keys() } changeUsageCount(n, r) { const o = this.usageCount; let i = o.get(n) ?? 0; return i += r, i > 0 ? o.set(n, i) : o.delete(n), i } ngOnDestroy() { for (const n of this.getAllStyles()) this.onStyleRemoved(n); this.usageCount.clear() } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(), Wr = (() => { class e extends Og { constructor(n) { super(), this.doc = n, this.styleRef = new Map, this.hostNodes = new Set, this.resetHostNodes() } onStyleAdded(n) { for (const r of this.hostNodes) this.addStyleToHost(r, n) } onStyleRemoved(n) { const r = this.styleRef; r.get(n)?.forEach(i => i.remove()), r.delete(n) } ngOnDestroy() { super.ngOnDestroy(), this.styleRef.clear(), this.resetHostNodes() } addHost(n) { this.hostNodes.add(n); for (const r of this.getAllStyles()) this.addStyleToHost(n, r) } removeHost(n) { this.hostNodes.delete(n) } addStyleToHost(n, r) { const o = this.doc.createElement("style"); o.textContent = r, n.appendChild(o); const i = this.styleRef.get(r); i ? i.push(o) : this.styleRef.set(r, [o]) } resetHostNodes() { const n = this.hostNodes; n.clear(), n.add(this.doc.head) } } return e.\u0275fac = function (n) { return new (n || e)(L(mt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const ku = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Lu = /%COMP%/g, jg = new A("RemoveStylesOnCompDestory", { providedIn: "root", factory: () => !1 }); function Hg(e, t) { return t.flat(100).map(n => n.replace(Lu, e)) } function Bg(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let ju = (() => { class e { constructor(n, r, o, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestory = i, this.rendererByCompId = new Map, this.defaultRenderer = new Hu(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; const o = this.getOrCreateRenderer(n, r); return o instanceof Ug ? o.applyToHost(n) : o instanceof Bu && o.applyStyles(), o } getOrCreateRenderer(n, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.eventManager, a = this.sharedStylesHost, u = this.removeStylesOnCompDestory; switch (r.encapsulation) { case at.Emulated: i = new Ug(s, a, r, this.appId, u); break; case at.ShadowDom: return new XS(s, a, n, r); default: i = new Bu(s, a, r, u) }i.onDestroy = () => o.delete(r.id), o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(L(Si), L(Wr), L(Br), L(jg)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); class Hu { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(ku[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { ($g(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && ($g(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = ku[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = ku[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (xe.DashCase | xe.Important) ? t.style.setProperty(n, r, o & xe.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & xe.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, Bg(r)) : this.eventManager.addEventListener(t, n, Bg(r)) } } function $g(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class XS extends Hu { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = Hg(o.id, o.styles); for (const s of i) { const a = document.createElement("style"); a.textContent = s, this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class Bu extends Hu { constructor(t, n, r, o, i = r.id) { super(t), this.sharedStylesHost = n, this.removeStylesOnCompDestory = o, this.rendererUsageCount = 0, this.styles = Hg(i, r.styles) } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestory && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class Ug extends Bu { constructor(t, n, r, o, i) { const s = o + "-" + r.id; super(t, n, r, i, s), this.contentAttr = function KS(e) { return "_ngcontent-%COMP%".replace(Lu, e) }(s), this.hostAttr = function YS(e) { return "_nghost-%COMP%".replace(Lu, e) }(s) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } let QS = (() => { class e extends Rg { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(L(mt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const zg = ["alt", "control", "meta", "shift"], JS = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, eM = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let tM = (() => { class e extends Rg { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => fi().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), zg.forEach(l => { const c = r.indexOf(l); c > -1 && (r.splice(c, 1), s += l + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const u = {}; return u.domEventName = o, u.fullKey = s, u } static matchEventFullKeyCode(n, r) { let o = JS[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), zg.forEach(s => { s !== o && (0, eM[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(L(mt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const iM = zp($I, "browser", [{ provide: ou, useValue: "browser" }, { provide: kp, useValue: function nM() { Ou.makeCurrent() }, multi: !0 }, { provide: mt, useFactory: function oM() { return function Sv(e) { Gs = e }(document), document }, deps: [] }]), qg = new A(""), Kg = [{ provide: ai, useClass: class US { addToWindow(t) { Y.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, Y.getAllAngularTestabilities = () => t.getAllTestabilities(), Y.getAllAngularRootElements = () => t.getAllRootElements(), Y.frameworkStabilizers || (Y.frameworkStabilizers = []), Y.frameworkStabilizers.push(r => { const o = Y.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? fi().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: Vp, useClass: uu, deps: [_e, lu, ai] }, { provide: uu, useClass: uu, deps: [_e, lu, ai] }], Yg = [{ provide: ta, useValue: "root" }, { provide: An, useFactory: function rM() { return new An }, deps: [] }, { provide: Ii, useClass: QS, multi: !0, deps: [mt, _e, ou] }, { provide: Ii, useClass: tM, multi: !0, deps: [mt] }, { provide: ju, useClass: ju, deps: [Si, Wr, Br, jg] }, { provide: Md, useExisting: ju }, { provide: Og, useExisting: Wr }, { provide: Wr, useClass: Wr, deps: [mt] }, { provide: Si, useClass: Si, deps: [Ii, _e] }, { provide: Tg, useClass: zS, deps: [] }, []]; let sM = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: Br, useValue: n.appId }, { provide: Fg, useExisting: Br }, $S] } } } return e.\u0275fac = function (n) { return new (n || e)(L(qg, 12)) }, e.\u0275mod = ln({ type: e }), e.\u0275inj = Gt({ providers: [...Yg, ...Kg], imports: [aS, UI] }), e })(); typeof window < "u" && window; class Mi { } class Uu { } class xt { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(n => { const r = n.indexOf(":"); if (r > 0) { const o = n.slice(0, r), i = o.toLowerCase(), s = n.slice(r + 1).trim(); this.maybeSetNormalizedName(o, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : () => { this.headers = new Map, Object.entries(t).forEach(([n, r]) => { let o; if (o = "string" == typeof r ? [r] : "number" == typeof r ? [r.toString()] : r.map(i => i.toString()), o.length > 0) { const i = n.toLowerCase(); this.headers.set(i, o), this.maybeSetNormalizedName(n, i) } }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const n = this.headers.get(t.toLowerCase()); return n && n.length > 0 ? n[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, n) { return this.clone({ name: t, value: n, op: "a" }) } set(t, n) { return this.clone({ name: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ name: t, value: n, op: "d" }) } maybeSetNormalizedName(t, n) { this.normalizedNames.has(n) || this.normalizedNames.set(n, t) } init() { this.lazyInit && (this.lazyInit instanceof xt ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(n => { this.headers.set(n, t.headers.get(n)), this.normalizedNames.set(n, t.normalizedNames.get(n)) }) } clone(t) { const n = new xt; return n.lazyInit = this.lazyInit && this.lazyInit instanceof xt ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([t]), n } applyUpdate(t) { const n = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let r = t.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(t.name, n); const o = ("a" === t.op ? this.headers.get(n) : void 0) || []; o.push(...r), this.headers.set(n, o); break; case "d": const i = t.value; if (i) { let s = this.headers.get(n); if (!s) return; s = s.filter(a => -1 === i.indexOf(a)), 0 === s.length ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, s) } else this.headers.delete(n), this.normalizedNames.delete(n) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(n => t(this.normalizedNames.get(n), this.headers.get(n))) } } class yM { encodeKey(t) { return Qg(t) } encodeValue(t) { return Qg(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } const vM = /%(\d[a-f0-9])/gi, wM = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function Qg(e) { return encodeURIComponent(e).replace(vM, (t, n) => wM[n] ?? t) } function Ti(e) { return `${e}` } class $t { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new yM, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function DM(e, t) { const n = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { const i = o.indexOf("="), [s, a] = -1 == i ? [t.decodeKey(o), ""] : [t.decodeKey(o.slice(0, i)), t.decodeValue(o.slice(i + 1))], u = n.get(s) || []; u.push(a), n.set(s, u) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(n => { const r = t.fromObject[n], o = Array.isArray(r) ? r.map(Ti) : [Ti(r)]; this.map.set(n, o) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const n = this.map.get(t); return n ? n[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, n) { return this.clone({ param: t, value: n, op: "a" }) } appendAll(t) { const n = []; return Object.keys(t).forEach(r => { const o = t[r]; Array.isArray(o) ? o.forEach(i => { n.push({ param: r, value: i, op: "a" }) }) : n.push({ param: r, value: o, op: "a" }) }), this.clone(n) } set(t, n) { return this.clone({ param: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ param: t, value: n, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const n = this.encoder.encodeKey(t); return this.map.get(t).map(r => n + "=" + this.encoder.encodeValue(r)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const n = new $t({ encoder: this.encoder }); return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(t), n } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const n = ("a" === t.op ? this.map.get(t.param) : void 0) || []; n.push(Ti(t.value)), this.map.set(t.param, n); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let r = this.map.get(t.param) || []; const o = r.indexOf(Ti(t.value)); -1 !== o && r.splice(o, 1), r.length > 0 ? this.map.set(t.param, r) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class _M { constructor() { this.map = new Map } set(t, n) { return this.map.set(t, n), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } } function Jg(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function em(e) { return typeof Blob < "u" && e instanceof Blob } function tm(e) { return typeof FormData < "u" && e instanceof FormData } class qr { constructor(t, n, r, o) { let i; if (this.url = n, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function EM(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== r ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params)), this.headers || (this.headers = new xt), this.context || (this.context = new _M), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = n; else { const a = n.indexOf("?"); this.urlWithParams = n + (-1 === a ? "?" : a < n.length - 1 ? "&" : "") + s } } else this.params = new $t, this.urlWithParams = n } serializeBody() { return null === this.body ? null : Jg(this.body) || em(this.body) || tm(this.body) || function CM(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof $t ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || tm(this.body) ? null : em(this.body) ? this.body.type || null : Jg(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof $t ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { const n = t.method || this.method, r = t.url || this.url, o = t.responseType || this.responseType, i = void 0 !== t.body ? t.body : this.body, s = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let u = t.headers || this.headers, l = t.params || this.params; const c = t.context ?? this.context; return void 0 !== t.setHeaders && (u = Object.keys(t.setHeaders).reduce((d, f) => d.set(f, t.setHeaders[f]), u)), t.setParams && (l = Object.keys(t.setParams).reduce((d, f) => d.set(f, t.setParams[f]), l)), new qr(n, r, i, { params: l, headers: u, context: c, reportProgress: a, responseType: o, withCredentials: s }) } } var ce = (() => ((ce = ce || {})[ce.Sent = 0] = "Sent", ce[ce.UploadProgress = 1] = "UploadProgress", ce[ce.ResponseHeader = 2] = "ResponseHeader", ce[ce.DownloadProgress = 3] = "DownloadProgress", ce[ce.Response = 4] = "Response", ce[ce.User = 5] = "User", ce))(); class zu { constructor(t, n = 200, r = "OK") { this.headers = t.headers || new xt, this.status = void 0 !== t.status ? t.status : n, this.statusText = t.statusText || r, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Gu extends zu { constructor(t = {}) { super(t), this.type = ce.ResponseHeader } clone(t = {}) { return new Gu({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Ai extends zu { constructor(t = {}) { super(t), this.type = ce.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Ai({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class nm extends zu { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Wu(e, t) { return { body: t, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let rm = (() => { class e { constructor(n) { this.handler = n } request(n, r, o = {}) { let i; if (n instanceof qr) i = n; else { let u, l; u = o.headers instanceof xt ? o.headers : new xt(o.headers), o.params && (l = o.params instanceof $t ? o.params : new $t({ fromObject: o.params })), i = new qr(n, r, void 0 !== o.body ? o.body : null, { headers: u, context: o.context, params: l, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials }) } const s = function pM(...e) { return El(e, Dl(e)) }(i).pipe(function gM(e, t) { return X(t) ? eo(e, t, 1) : eo(e, 1) }(u => this.handler.handle(u))); if (n instanceof qr || "events" === o.observe) return s; const a = s.pipe(function mM(e, t) { return an((n, r) => { let o = 0; n.subscribe(Jn(r, i => e.call(t, i, o++) && r.next(i))) }) }(u => u instanceof Ai)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(er(u => { if (null !== u.body && !(u.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return u.body })); case "blob": return a.pipe(er(u => { if (null !== u.body && !(u.body instanceof Blob)) throw new Error("Response is not a Blob."); return u.body })); case "text": return a.pipe(er(u => { if (null !== u.body && "string" != typeof u.body) throw new Error("Response is not a string."); return u.body })); default: return a.pipe(er(u => u.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(n, r = {}) { return this.request("DELETE", n, r) } get(n, r = {}) { return this.request("GET", n, r) } head(n, r = {}) { return this.request("HEAD", n, r) } jsonp(n, r) { return this.request("JSONP", n, { params: (new $t).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(n, r = {}) { return this.request("OPTIONS", n, r) } patch(n, r, o = {}) { return this.request("PATCH", n, Wu(o, r)) } post(n, r, o = {}) { return this.request("POST", n, Wu(o, r)) } put(n, r, o = {}) { return this.request("PUT", n, Wu(o, r)) } } return e.\u0275fac = function (n) { return new (n || e)(L(Mi)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); function om(e, t) { return t(e) } function bM(e, t) { return (n, r) => t.intercept(n, { handle: o => e(o, r) }) } const SM = new A("HTTP_INTERCEPTORS"), Kr = new A("HTTP_INTERCEPTOR_FNS"); function MM() { let e = null; return (t, n) => (null === e && (e = (rr(SM, { optional: !0 }) ?? []).reduceRight(bM, om)), e(t, n)) } let im = (() => { class e extends Mi { constructor(n, r) { super(), this.backend = n, this.injector = r, this.chain = null } handle(n) { if (null === this.chain) { const r = Array.from(new Set(this.injector.get(Kr))); this.chain = r.reduceRight((o, i) => function IM(e, t, n) { return (r, o) => n.runInContext(() => t(r, i => e(i, o))) }(o, i, this.injector), om) } return this.chain(n, r => this.backend.handle(r)) } } return e.\u0275fac = function (n) { return new (n || e)(L(Uu), L(Jt)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const PM = /^\)\]\}',?\n/; let am = (() => { class e { constructor(n) { this.xhrFactory = n } handle(n) { if ("JSONP" === n.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new Ee(r => { const o = this.xhrFactory.build(); if (o.open(n.method, n.urlWithParams), n.withCredentials && (o.withCredentials = !0), n.headers.forEach((h, p) => o.setRequestHeader(h, p.join(","))), n.headers.has("Accept") || o.setRequestHeader("Accept", "application/json, text/plain, */*"), !n.headers.has("Content-Type")) { const h = n.detectContentTypeHeader(); null !== h && o.setRequestHeader("Content-Type", h) } if (n.responseType) { const h = n.responseType.toLowerCase(); o.responseType = "json" !== h ? h : "text" } const i = n.serializeBody(); let s = null; const a = () => { if (null !== s) return s; const h = o.statusText || "OK", p = new xt(o.getAllResponseHeaders()), g = function xM(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(o) || n.url; return s = new Gu({ headers: p, status: o.status, statusText: h, url: g }), s }, u = () => { let { headers: h, status: p, statusText: g, url: v } = a(), D = null; 204 !== p && (D = typeof o.response > "u" ? o.responseText : o.response), 0 === p && (p = D ? 200 : 0); let _ = p >= 200 && p < 300; if ("json" === n.responseType && "string" == typeof D) { const m = D; D = D.replace(PM, ""); try { D = "" !== D ? JSON.parse(D) : null } catch (b) { D = m, _ && (_ = !1, D = { error: b, text: D }) } } _ ? (r.next(new Ai({ body: D, headers: h, status: p, statusText: g, url: v || void 0 })), r.complete()) : r.error(new nm({ error: D, headers: h, status: p, statusText: g, url: v || void 0 })) }, l = h => { const { url: p } = a(), g = new nm({ error: h, status: o.status || 0, statusText: o.statusText || "Unknown Error", url: p || void 0 }); r.error(g) }; let c = !1; const d = h => { c || (r.next(a()), c = !0); let p = { type: ce.DownloadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), "text" === n.responseType && o.responseText && (p.partialText = o.responseText), r.next(p) }, f = h => { let p = { type: ce.UploadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), r.next(p) }; return o.addEventListener("load", u), o.addEventListener("error", l), o.addEventListener("timeout", l), o.addEventListener("abort", l), n.reportProgress && (o.addEventListener("progress", d), null !== i && o.upload && o.upload.addEventListener("progress", f)), o.send(i), r.next({ type: ce.Sent }), () => { o.removeEventListener("error", l), o.removeEventListener("abort", l), o.removeEventListener("load", u), o.removeEventListener("timeout", l), n.reportProgress && (o.removeEventListener("progress", d), null !== i && o.upload && o.upload.removeEventListener("progress", f)), o.readyState !== o.DONE && o.abort() } }) } } return e.\u0275fac = function (n) { return new (n || e)(L(Tg)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); const qu = new A("XSRF_ENABLED"), um = new A("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }), lm = new A("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class cm { } let OM = (() => { class e { constructor(n, r, o) { this.doc = n, this.platform = r, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const n = this.doc.cookie || ""; return n !== this.lastCookieString && (this.parseCount++, this.lastToken = mg(n, this.cookieName), this.lastCookieString = n), this.lastToken } } return e.\u0275fac = function (n) { return new (n || e)(L(mt), L(ou), L(um)) }, e.\u0275prov = G({ token: e, factory: e.\u0275fac }), e })(); function kM(e, t) { const n = e.url.toLowerCase(); if (!rr(qu) || "GET" === e.method || "HEAD" === e.method || n.startsWith("http://") || n.startsWith("https://")) return t(e); const r = rr(cm).getToken(), o = rr(lm); return null != r && !e.headers.has(o) && (e = e.clone({ headers: e.headers.set(o, r) })), t(e) } var ie = (() => ((ie = ie || {})[ie.Interceptors = 0] = "Interceptors", ie[ie.LegacyInterceptors = 1] = "LegacyInterceptors", ie[ie.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", ie[ie.NoXsrfProtection = 3] = "NoXsrfProtection", ie[ie.JsonpSupport = 4] = "JsonpSupport", ie[ie.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", ie))(); function Zn(e, t) { return { \u0275kind: e, \u0275providers: t } } function LM(...e) { const t = [rm, am, im, { provide: Mi, useExisting: im }, { provide: Uu, useExisting: am }, { provide: Kr, useValue: kM, multi: !0 }, { provide: qu, useValue: !0 }, { provide: cm, useClass: OM }]; for (const n of e) t.push(...n.\u0275providers); return function Zv(e) { return { \u0275providers: e } }(t) } const dm = new A("LEGACY_INTERCEPTOR_FN"); let HM = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = ln({ type: e }), e.\u0275inj = Gt({ providers: [LM(Zn(ie.LegacyInterceptors, [{ provide: dm, useFactory: MM }, { provide: Kr, useExisting: dm, multi: !0 }]))] }), e })(), BM = (() => { class e { constructor() { this.title = "" } ngOnInit() { this.color = this.title.trim().toLowerCase() } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = Ji({ type: e, selectors: [["app-tracking"]], inputs: { title: "title", current: "current", previous: "previous", ImageSource: "ImageSource" }, decls: 14, vars: 5, consts: [[1, "card"], [1, "overlay", 3, "ngClass"], ["alt", "Card image cap", 1, "card-img-top", "z-index-2", 3, "src"], [1, "card-body"], [1, "d-flex", "justify-content-between", "mb-4"], ["src", "./assets/images/icon-ellipsis.svg", "alt", "icon-ellipsis"], [1, "text", "d-flex", "flex-md-column", "justify-content-between", "align-items-center", "align-items-md-start"], [1, "m-0"]], template: function (r, o) { 1 & r && (Se(0, "div", 0)(1, "div", 1), Un(2, "img", 2), Re(), Se(3, "div", 3)(4, "div", 4)(5, "h5"), St(6), Re(), Se(7, "a"), Un(8, "img", 5), Re()(), Se(9, "div", 6)(10, "h1", 7), St(11), Re(), Se(12, "p", 7), St(13), Re()()()()), 2 & r && (en(1), $n("ngClass", o.color), en(1), $n("src", o.ImageSource, Xs), en(4), Pr(o.title), en(5), Pr(o.current + "hrs"), en(2), Pr("last week - " + o.previous + "hrs")) }, dependencies: [Dg], styles: [".card[_ngcontent-%COMP%]{background-color:transparent;border:none;width:100%}.overlay[_ngcontent-%COMP%]{position:relative;height:75px;overflow:hidden;border-radius:20px}.overlay[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;top:-10px;right:20px;width:65px;filter:brightness(0%);opacity:20%}.card-body[_ngcontent-%COMP%]{background-color:var(--Dark-blue);padding:clamp(25px,4vw,35px);border-radius:20px;color:#fff;position:relative;top:-35px;cursor:pointer}.card-body[_ngcontent-%COMP%]:hover{background-color:var(--Desaturated-blue)}.card-body[_ngcontent-%COMP%]   h5[_ngcontent-%COMP%]{font-size:18px}.card-body[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:clamp(24px,4vw,48px);font-weight:300}.card-body[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:var(--Pale-Blue);font-size:14px}.work[_ngcontent-%COMP%]{background-color:var(--Light-orange)}.play[_ngcontent-%COMP%]{background-color:var(--Soft-blue)}.study[_ngcontent-%COMP%]{background-color:var(--Light-red)}.exercise[_ngcontent-%COMP%]{background-color:var(--Lime-green)}.social[_ngcontent-%COMP%]{background-color:var(--Violet)}.self[_ngcontent-%COMP%]{background-color:var(--Soft-yellow)}"] }) } return e })(); function VM(e, t) { if (1 & e && Un(0, "app-tracking", 10), 2 & e) { const n = t.$implicit, r = t.index, o = Pf(); $n("title", n.title)("current", n.timeframes[o.type].current)("previous", n.timeframes[o.type].previous)("ImageSource", o.ImageSources[r]) } } let $M = (() => { class e { constructor(n) { this.http = n, this.title = "time-tracking-dashboard", this.type = "monthly", this.ImageSources = ["./assets/images/icon-work.svg", "~/./assets/images/icon-play.svg", "./assets/images/icon-study.svg", "./assets/images/icon-exercise.svg", "./assets/images/icon-social.svg", "./assets/images/icon-self-care.svg"] } ngOnInit() { this.http.get("../assets/data.json").subscribe(o => { this.data = o }) } showdaily() { this.type = "daily" } showmonthly() { this.type = "monthly" } showweekly() { this.type = "weekly" } static #e = this.\u0275fac = function (r) { return new (r || e)(k(rm)) }; static #t = this.\u0275cmp = Ji({ type: e, selectors: [["app-root"]], decls: 18, vars: 1, consts: [[1, "container", "justify-content-center", "align-items-center", "d-flex", "flex-column", "flex-lg-row", "gap-3"], [1, "profile", "card", "col-12", "col-lg-3"], [1, "box", "d-flex", "flex-lg-column", "gap-2", "gap-lg-5", "align-items-lg-start", "align-items-center", "justify-content-center"], ["src", "../assets/images/image-jeremy.png", "alt", "image-jeremy"], [1, "info"], [1, "menu-type", "d-flex", "flex-lg-column", "align-items-lg-start", "gap-4", "align-items-center", "justify-content-center"], ["type", " button", 3, "click"], ["type", "button", 3, "click"], [1, "d-flex", "justify-content-center", "align-items-center", "gap-3", "flex-wrap", "p-0", "col-12", "col-lg-9"], ["class", "tracking", 3, "title", "current", "previous", "ImageSource", 4, "ngFor", "ngForOf"], [1, "tracking", 3, "title", "current", "previous", "ImageSource"]], template: function (r, o) { 1 & r && (Se(0, "main", 0)(1, "div", 1)(2, "div", 2), Un(3, "img", 3), Se(4, "div", 4)(5, "span"), St(6, "Report for"), Re(), Se(7, "h1"), St(8, "Jermy Robson"), Re()()(), Se(9, "div", 5)(10, "a", 6), Ar("click", function () { return o.showdaily() }), St(11, "Daily"), Re(), Se(12, "a", 7), Ar("click", function () { return o.showmonthly() }), St(13, "Monthly"), Re(), Se(14, "a", 7), Ar("click", function () { return o.showweekly() }), St(15, "Weekly"), Re()()(), Se(16, "ul", 8), function bf(e, t, n, r, o, i, s, a) { const u = y(), l = H(), c = e + Z, d = l.firstCreatePass ? function X_(e, t, n, r, o, i, s, a, u) { const l = t.consts, c = xn(t, e, 4, s || null, Lt(l, a)); va(t, n, c, Lt(l, u)), Do(t, c); const d = c.tView = Da(2, c, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, l); return null !== t.queries && (t.queries.template(t, c), d.queries = t.queries.embeddedTView(c)), c }(c, l, u, t, n, r, o, i, s) : l.data[c]; lt(d, !1); const f = u[O].createComment(""); Fo(l, u, f, d), ve(f, u), zo(u, u[c] = tf(f, u, f, d)), po(d) && ma(l, u, d), null != s && ya(u, d, a) }(17, VM, 1, 4, "app-tracking", 9), Re()()), 2 & r && (en(17), $n("ngForOf", o.data)) }, dependencies: [_g, BM], styles: ["main[_ngcontent-%COMP%]{min-height:100vh;padding:20px}.card[_ngcontent-%COMP%]{background-color:transparent;border:none;width:100%;z-index:1}.box[_ngcontent-%COMP%]{background-color:var(--Blue);padding:35px;border-radius:20px;color:#fff;z-index:3}.box[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:var(--Pale-Blue);font-size:clamp(12px,3vw,16px)}.box[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:clamp(20px,3vw,40px);font-weight:400}.card[_ngcontent-%COMP%]   .box[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:70px;border:2px solid white;border-radius:50%}.menu-type[_ngcontent-%COMP%]{background-color:var(--Dark-blue);color:var(--Pale-Blue);border-radius:20px;position:relative;top:-30px;z-index:2;padding:60px 35px 35px}a[_ngcontent-%COMP%]{color:var(--Pale-Blue)!important;cursor:pointer}a[_ngcontent-%COMP%]:hover{color:#fff!important}@media (max-width: 767px){.tracking[_ngcontent-%COMP%]{width:100%}}@media (min-width: 768px){.tracking[_ngcontent-%COMP%]{width:48%}}@media (min-width: 992px){.tracking[_ngcontent-%COMP%], .profile[_ngcontent-%COMP%]{max-width:256px;width:30%}}"] }) } return e })(), UM = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = ln({ type: e, bootstrap: [$M] }); static #n = this.\u0275inj = Gt({ imports: [sM, HM] }) } return e })(); iM().bootstrapModule(UM).catch(e => console.error(e)) } }, X => { X(X.s = 2) }]);
